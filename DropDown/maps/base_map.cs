
namespace DropDown {

    using Core;
    using Core.physics;
    using Core.render;
    using Core.util;
    using Core.world;
    using Core.world.map;
    using ImGuiNET;
    using OpenTK.Mathematics;
    using System.Diagnostics;

    public class base_map : map {

        public base_map() {

            //this.generate_backgound_tile(50, 30);

            //physics_material ateroid_phys_mat = new physics_material(0.0f, 0.1f);
            //Texture ateroid_texture = resource_manager.get_texture("assets/textures/muzzle_flash.jpg");
            //this.add_game_object(
            //    new game_object(new Vector2(550, -350), new Vector2(300, 100))
            //        .set_sprite(ateroid_texture)
            //        .set_mobility(mobility.STATIC)
            //        .add_collider(new collider(collision_shape.Square)));


            //this.add_character(new character().add_collider(new collider()), new Vector2(-300));

            this.cell_size = 100;
            this.min_distanc_for_collision = (float)(this.cell_size * this.tile_size);
            generate_bit_map();
            generate_actual_map();

        }

        public void generate_map_from_bit_map() {
            
        }

        public override void draw_imgui() {

            imgui_diaplay_level_bit_map();
        }

        private void imgui_diaplay_level_bit_map() {

            if(!ImGui.Begin("level_bit_map"))
                return;

            imgui_util.title("Data for map:");

            imgui_util.begin_default_table("bit_map_generation_data");
            imgui_util.add_table_row("inital density", ref inital_density, 0.0002f, 0f, 1f);
            imgui_util.add_table_row("tile display size", ref tile_display_size, 0.1f, 3, 10);
            imgui_util.end_default_table();

            imgui_util.begin_default_table("bit_map_generation_data");
            imgui_util.add_table_row("Iterations count", () => { 
                ImGui.Text($"{iterations.Length}");
                ImGui.SameLine();
                if(ImGui.Button("+##add to iterations")) {

                    int[] buffer = new int[iterations.Length + 1];
                    Array.Copy(iterations, buffer, iterations.Length);
                    buffer[buffer.Length - 1] = 4;
                    iterations = buffer;
                }
                ImGui.SameLine();
                if(ImGui.Button("-##add to iterations")) {

                    int[] buffer = new int[iterations.Length - 1];
                    Array.Copy(iterations, buffer, iterations.Length - 1);
                    iterations = buffer;
                }
            } );
            imgui_util.end_default_table();

            for (int x = 0; x < iterations.Length; x++) {
                
                ImGui.VSliderInt($"##int{x}", new System.Numerics.Vector2(18, 60), ref iterations[x], 0, 8);
                ImGui.SameLine();
            }
            
            if(ImGui.Button("Regenerate")) {
                generate_bit_map();
            }
            
            imgui_util.title("Map generated by cellular automata:");

            ImDrawListPtr draw_list = ImGui.GetWindowDrawList();
            var wondopw_pos = ImGui.GetWindowPos() + ImGui.GetCursorPos() - new System.Numerics.Vector2(0, ImGui.GetScrollY());
            uint col_white = ImGui.GetColorU32(new System.Numerics.Vector4(0.2f, 0.2f, 0.2f, 1));
            uint col_black = ImGui.GetColorU32(new System.Numerics.Vector4(0.9f, 0.9f, 0.9f, 1));

            // display bit map
            for(int x = 0; x < 64; x++) {
                for(int y = 63; y >= 0 ; y--) {

                    UInt64 currentBit = (floor_layout[x] >> y) & 1;

                    draw_list.AddRectFilled(
                        wondopw_pos + new System.Numerics.Vector2(y * tile_display_size, x * tile_display_size),
                        wondopw_pos + new System.Numerics.Vector2((y + 1) * tile_display_size, (x+1) * tile_display_size),
                        (currentBit == 0) ? col_black : col_white);
                }
            }

            // display bit map
            uint col_red = ImGui.GetColorU32(new System.Numerics.Vector4(0.9f, 0.2f, 0.2f, 1));
            for(int x = 1; x < 8; x++) {

                // draw X-Axis Line
                draw_list.AddLine(
                    wondopw_pos + new System.Numerics.Vector2(0, x * tile_display_size * 8),
                    wondopw_pos + new System.Numerics.Vector2(64 * tile_display_size, x * tile_display_size * 8),
                    col_red);

                // draw Y-Axis Line
                draw_list.AddLine(
                    wondopw_pos + new System.Numerics.Vector2(x * tile_display_size * 8, 0),
                    wondopw_pos + new System.Numerics.Vector2(x * tile_display_size * 8, 64 * tile_display_size),
                    col_red);

            }


            // show player position
            draw_list.AddRectFilled(
                wondopw_pos + new System.Numerics.Vector2(32 * tile_display_size, 32 * tile_display_size),
                wondopw_pos + new System.Numerics.Vector2((32 + 1) * tile_display_size, (32 + 1) * tile_display_size),
                ImGui.GetColorU32(new System.Numerics.Vector4(0.2f, 0.9f, 0.2f, 1)));

            imgui_util.shift_cursor_pos(0,64 * tile_display_size + 5);

            imgui_util.begin_default_table("map_generation_result");
            imgui_util.add_table_row("Bit-map generation duration", $"{bit_map_generation_duration} ms");
            imgui_util.add_table_row("convert to actual map duration", $"{map_generation_duration} ms");
            imgui_util.add_table_row("collision generation", $"{collision_generation_duration} ms");
            imgui_util.add_table_row("generation until start_pos empty", $"{bit_map_generation_iteration}");
            imgui_util.add_table_row("Total duration", $"{bit_map_generation_duration + map_generation_duration + collision_generation_duration} ms");
            imgui_util.end_default_table();

            if(ImGui.Button("Generate actual map from bit-map"))
                generate_actual_map();

            ImGui.End();
        }

        private void generate_actual_map() {

            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();

            // --------------------------- spawn sprites --------------------------- 
            Random rnd = new Random();
            force_clear_map_tiles();
            const int totalBits = sizeof(UInt64) * 8;
            for(int x = 0; x < totalBits; x++) {
                for(int y = 0; y < totalBits; y++) {

                    // Extract bits of current X
                    UInt64 currentBit = (floor_layout[x] >> y) & 1;

                    if(currentBit == 1)
                        continue;


                    double probebilits = rnd.NextDouble();
                    if(probebilits < 0.05f) {

                        this.add_background_sprite(
                            new sprite(texture_buffer).select_texture_region(32, 64, 3, 58 ),
                            new Vector2((y - totalBits/2) * this.cell_size, (x - totalBits/2) * this.cell_size));
                    }

                    else if(probebilits < 0.2f) {

                        this.add_background_sprite(
                            new sprite(texture_buffer).select_texture_region(32, 64, 4, 58),
                            new Vector2((y - totalBits / 2) * this.cell_size, (x - totalBits / 2) * this.cell_size));
                    }
                    
                    else {

                        this.add_background_sprite(
                            new sprite(texture_buffer).select_texture_region(32, 64, 5, 58),
                            new Vector2((y - totalBits / 2) * this.cell_size, (x - totalBits / 2) * this.cell_size));
                    }

                }
            }

            stopwatch.Stop();
            map_generation_duration = stopwatch.Elapsed.TotalMilliseconds;
            stopwatch.Restart();

            // --------------------------- generate collision --------------------------- 

            for(int x = 0; x < totalBits / tile_size; x++) {
                for(int y = 0; y < totalBits / tile_size; y++) {

                    Vector2 tile_offset = new Vector2(
                        ((x- ((totalBits / tile_size)/2)) * (this.tile_size * this.cell_size)),
                        ((y- ((totalBits / tile_size)/2)) * (this.tile_size * this.cell_size)));

                    // Display each byte in the array as a binary string
                    byte[] current_tile = get8x8_block(x, y);
                    for(int z = 0; z < current_tile.Length; z++) {

                        // repeat untill all bit are 0 in this byte (auto skips empty bytes)
                        while(current_tile[z] != 0) {

                            // --------------- find block of ones --------------- 
                            byte buffer = current_tile[z];
                            int firstOneIndex = -1;
                            int target_count = 0;                               // used as X value of size
                            int row_counter = 1;                                // used as Y value of size

                            // --------------- calc max size.X of collider --------------- 
                            for(int i = 0; i < 8; i++) {
                                if((buffer & (1 << i)) == 0)
                                    continue;

                                firstOneIndex = i;
                                target_count = count_number_of_following_ones(buffer, firstOneIndex);
                                break;
                            }
                            
                            // --------------- calc max size.Y of collider --------------- 
                            int questionable_count = 0;
                            do {

                                if(z + 1 > 7)
                                    break;
                                
                                questionable_count = count_number_of_following_ones(current_tile[z + row_counter], firstOneIndex);
                                if(questionable_count < target_count)
                                    break;

                                row_counter++;

                            } while((z + row_counter) < current_tile.Length && questionable_count >= target_count);
                            //Console.WriteLine($"size of collider: {target_count}/{row_counter}");

                            Vector2 collider_tile_offset = new Vector2(
                                (this.cell_size * -0.5f) + firstOneIndex * this.cell_size,
                                (this.cell_size * -0.5f) + z * this.cell_size
                                );

                            // --------------- add collider --------------- 

                            this.add_static_game_object(
                                new game_object(
                                    null,
                                    new Vector2(target_count * this.cell_size, row_counter * this.cell_size))
                                        .add_collider(new collider(collision_shape.Square)),
                                new Vector2((target_count * this.cell_size) / 2, (row_counter * this.cell_size) / 2) + tile_offset + collider_tile_offset,
                                false);

                            // --------------- set used values to 0 --------------- 
                            byte reset_mask = SetBits(firstOneIndex, target_count);
                            for(int i = 0; i < row_counter; i++) 
                                current_tile[z + i] = (byte)(current_tile[z + i] & ~reset_mask);

                        }
                    }
                }
            }

            stopwatch.Stop();
            collision_generation_duration = stopwatch.Elapsed.TotalMilliseconds;
        }

        private static byte SetBits(int start_index, int count) {

            byte result = 0;
            byte mask = (byte)((1 << count) - 1);   // Creates a sequence of 'count' ones
            mask <<= start_index;                   // Shift the mask to the left by 'start_index' positions
            result |= mask;

            return result;
        }

        private int count_number_of_following_ones(byte target, int index_of_first_one) {

            int count = 0;
            byte buffer = target;
            byte mask = 0x01; // Start with the least significant bit (LSB) mask
            mask <<= index_of_first_one;
            int buffer_index = index_of_first_one;

            // Iterate over each bit of the byte value
            while((buffer & mask) != 0 && buffer_index < 8) {
                count++; // Increment the count for each '1' encountered
                mask <<= 1; // Shift the mask to the left to check the next bit
            }
            return count;
        }

        private byte[] get8x8_block(int tile_index_x, int tile_index_y) {

            const int loc_tile_size = 8;
            const int totalBits = sizeof(UInt64) * 8;
            if(tile_index_x < 0 || tile_index_x > (totalBits/loc_tile_size) || tile_index_y < 0 || tile_index_y > (totalBits/loc_tile_size)) 
                throw new ArgumentException("Invalid startRow or startCol for extracting 8x8 block.");

            // Iterate over the rows of the 8x8 block
            UInt64 int_buffer = 0;
            byte[] block = new byte[8];
            for(int x = 0; x < 8; x++) {

                int_buffer = floor_layout[(tile_index_y*loc_tile_size) + x];
                block[x] = (byte)((int_buffer >> (tile_index_x * 8)) & 0xFF);
            }

            return block;
        }


        private void generate_bit_map() {

            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            bit_map_generation_iteration = 0;

            bool found = false;
            while(found == false && bit_map_generation_iteration < 1000) {

                // Call the method or perform the process you want to measure
                generate_random_64x64_bit_map();
                for(int x = 0; x < iterations.Length; x++) {

                    //Console.WriteLine($"ITERATION: {x}");
                    iterate_over_bit_map(iterations[x]);
                }

                UInt64 targetUInt64 = floor_layout[32];
                UInt64 mask = (UInt64)1 << 32;

                found = (targetUInt64 & mask) == 0;
                bit_map_generation_iteration++;
                Console.WriteLine($"player loc is empty: {found}");
            }

            stopwatch.Stop();
            bit_map_generation_duration = stopwatch.Elapsed.TotalMilliseconds;

        }

        private void generate_random_64x64_bit_map() {

            for(int x = 0; x < 64; x++) {

                floor_layout[x] = generate_random_UInt64_with_density(inital_density);
            }

        }

        private void iterate_over_bit_map(int threshhold = 4) {

            floor_layout_buffer = new UInt64[64];

            // Determine the number of bits in UInt64 (64 bits)
            const int totalBits = sizeof(UInt64) * 8;

            for(int x = 0;x < totalBits;x++) {

                // Loop through each bit position
                for(int y = totalBits - 1; y >= 0; y--) {

                    // Extract bits of current X
                    UInt64 currentBit = (floor_layout[x] >> y) & 1;
                    UInt64 previousBit = (y > 0) ? ((floor_layout[x] >> (y - 1)) & 1) : 1;
                    UInt64 nextBit = (y < totalBits - 1) ? ((floor_layout[x] >> (y + 1)) & 1) : 1;
                    UInt32 combinedBits = (UInt32)((nextBit << 2) | (currentBit << 1) | previousBit);

                    // Extract bits of u64 one above X
                    UInt64 upper_buffer = ((x - 1) < 0)? UInt64.MaxValue: floor_layout[x - 1];
                    UInt64 upper_currentBit = (upper_buffer >> y) & 1;
                    UInt64 upper_previousBit = (y > 0) ? ((upper_buffer >> (y - 1)) & 1) : 1;
                    UInt64 upper_nextBit = (y < totalBits - 1) ? ((upper_buffer >> (y + 1)) & 1) : 1;
                    UInt32 upper_combinedBits = (UInt32)((upper_nextBit << 2) | (upper_currentBit << 1) | upper_previousBit);

                    // Extract bits of u64 one below X
                    UInt64 lower_buffer = ((x + 1) > totalBits-1)? UInt64.MaxValue: floor_layout[x + 1];
                    UInt64 lower_currentBit = (lower_buffer >> y) & 1;
                    UInt64 lower_previousBit = (y > 0) ? ((lower_buffer >> (y - 1)) & 1) : 1;
                    UInt64 lower_nextBit = (y < totalBits - 1) ? ((lower_buffer >> (y + 1)) & 1) : 1;
                    UInt32 lower_combinedBits = (UInt32)((lower_nextBit << 2) | (lower_currentBit << 1) | lower_previousBit);

                    int count = count_ones_exclude_middle(combinedBits) + count_ones(upper_combinedBits) + count_ones(lower_combinedBits);

                    if(count >= threshhold) {

                        UInt64 mask = (UInt64)1 << y; // Calculate the mask based on MSB index (63 - bitIndex)
                        floor_layout_buffer[x] |= mask;
                    }

                    //Console.Write($"{count} ");

                }
                //Console.WriteLine();
            }


            //for(int x = 0; x < 64; x++)
            //    log_u64(bit_map_buffer[x]);

            //Console.WriteLine();
            floor_layout = floor_layout_buffer;
        }

        // imgui Window
        private float tile_display_size = 7;
        private double bit_map_generation_duration = 0;
        private double bit_map_generation_iteration = 0;
        private double map_generation_duration = 0;
        private double collision_generation_duration = 0;

        private float inital_density = 0.37f;
        private int[] iterations = new int[] {4,4,4,4,4};
        private static Random random = new Random();
        private UInt64[] floor_layout_buffer = new UInt64[64];
        private UInt64[] floor_layout = new UInt64[64];
        private readonly UInt64 map_bit_mask = 0xEFFFFFFFFFFFFFFE; // Binary: 01111111 11111111 11111111 11111111 11111111 11111111 11111111 11111110
        private Texture texture_buffer = resource_manager.get_texture("assets/textures/terrain.png");

        private void log_u64(UInt64 number) {

            string binaryRepresentation = Convert.ToString((long)number, 2).PadLeft(64, '0');

            // Replace '0' with ' ' (space) and '1' with 'X'
            char[] binaryChars = binaryRepresentation.Select(c => c == '0' ? ' ' : 'X').ToArray();
            string formattedBinary = new string(binaryChars);

            Console.WriteLine($"Map: |{formattedBinary}|");
        }


        // Function to count the number of '1's in a 3-bit number
        private static int count_ones(uint num) {

            int count = 0;
            for(int i = 0; i < 3; i++) {
                if((num & (1 << i)) != 0)
                    count++;
            }
            return count;
        }

        // Function to count the number of '1's in the leftmost and rightmost bits of a 3-bit number
        private static int count_ones_exclude_middle(uint num) {

            int count = 0;
            for(int i = 0; i <= 2; i += 2) {
                if((num & (1 << i)) != 0) 
                    count++;
            }
            return count;
        }

        // Function to generate a UInt64 value with specified density of bits flipped
        static UInt64 generate_random_UInt64_with_density(double density) {

            Random random = new Random();
            UInt64 result = 0;
            for(int i = 0; i < 64; i++) {
            
                double randomValue = random.NextDouble();
                if(randomValue < density)
                    result |= (UInt64)1 << i;
            }
            return result;
        }

    }
}


/*



*/