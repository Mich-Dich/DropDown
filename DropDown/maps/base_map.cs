using Core;
using Core.game_objects;
using Core.physics;
using Core.physics.material;
using Core.util;
using ImGuiNET;
using OpenTK.Mathematics;

namespace Hell {

    public class base_map : map {

        public base_map() {

            this.generate_backgound_tile(50, 30);

            physics_material ateroid_phys_mat = new physics_material(0.0f, 0.0f, 0.1f);
            
            Texture ateroid_texture = resource_manager.get_texture("assets/textures/muzzle_flash.jpg");
            this.add_game_object(
                new game_object(new Vector2(550, -350), new Vector2(300, 100))
                    .set_sprite(ateroid_texture)
                    .set_mobility(mobility.STATIC)
                    .add_collider(new collider(collision_shape.Square)));


            //this.add_character(new character().add_collider(new collider()), new Vector2(-300));

            generate_mbit_map();
        }

        public override void draw_imgui() {

            imgui_diaplay_level_bit_map();
        }

        public void imgui_diaplay_level_bit_map() {

            ImGui.Begin("level_bit_map");

            imgui_util.title("Data for map:");

            imgui_util.begin_default_table("bit_map_generation_data");
            imgui_util.add_table_row("inital density", ref inital_density, 0.0002f, 0f, 1f);
            imgui_util.add_table_row("tile display size", ref tile_display_size, 1, 1, 10);
            imgui_util.end_default_table();

            imgui_util.begin_default_table("bit_map_generation_data");
            imgui_util.add_table_row("Iterations count", () => { 
                ImGui.Text($"{iterations.Length}");
                ImGui.SameLine();
                if(ImGui.Button("+##add to iterations", new System.Numerics.Vector2(15, 15))) {

                    int[] buffer = new int[iterations.Length + 1];
                    Array.Copy(iterations, buffer, iterations.Length);
                    buffer[buffer.Length - 1] = 4;
                    iterations = buffer;
                }
                ImGui.SameLine();
                if(ImGui.Button("-##add to iterations")) {

                    int[] buffer = new int[iterations.Length - 1];
                    Array.Copy(iterations, buffer, iterations.Length - 1);
                    iterations = buffer;
                }
            } );
            imgui_util.end_default_table();

            for (int x = 0; x < iterations.Length; x++) {
                
                ImGui.VSliderInt($"##int{x}", new System.Numerics.Vector2(18, 60), ref iterations[x], 0, 8);
                ImGui.SameLine();
            }
            
            if(ImGui.Button("Regenerate")) {
                generate_mbit_map();
            }
            
            imgui_util.title("Map generated by cellular automata:");

            ImDrawListPtr draw_list = ImGui.GetWindowDrawList();
            var wondopw_pos = ImGui.GetWindowPos() + ImGui.GetCursorPos() - new System.Numerics.Vector2(0, ImGui.GetScrollY());
            uint col_white = ImGui.GetColorU32(new System.Numerics.Vector4(0.2f, 0.2f, 0.2f, 1));
            uint col_black = ImGui.GetColorU32(new System.Numerics.Vector4(0.9f, 0.9f, 0.9f, 1));


            for(int x = 0; x < 64; x++) {
                for(int y = 0; y < 64; y++) {

                    UInt64 currentBit = (floor_layout[x] >> y) & 1;

                    draw_list.AddRectFilled(
                        wondopw_pos + new System.Numerics.Vector2(y * tile_display_size, x * tile_display_size),
                        wondopw_pos + new System.Numerics.Vector2((y + 1) * tile_display_size, (x+1) * tile_display_size),
                        (currentBit == 0) ? col_black : col_white);
                }
            }
            imgui_util.shift_cursor_pos(0,64 * tile_display_size + 5);

            ImGui.End();
        }

        private void generate_mbit_map() {

            generate_random_64x64_bit_map();
            for(int x = 0; x < iterations.Length; x++) {

                //Console.WriteLine($"ITERATION: {x}");
                iterate_over_bit_map(iterations[x]);
            }

        }

        private void generate_random_64x64_bit_map() {

            for(int x = 0; x < 64; x++) {

                floor_layout[x] = generate_random_UInt64_with_density(inital_density);
                //log_u64(floor_layout[x]);
            }

        }

        private void iterate_over_bit_map(int threshhold = 4) {

            UInt64[] bit_map_buffer = new UInt64[64];

            // Determine the number of bits in UInt64 (64 bits)
            const int totalBits = sizeof(UInt64) * 8;

            for(int x = 0;x < totalBits;x++) {

                // Loop through each bit position
                for(int y = totalBits - 1; y >= 0; y--) {

                    // Extract bits of current X
                    UInt64 currentBit = (floor_layout[x] >> y) & 1;
                    UInt64 previousBit = (y > 0) ? ((floor_layout[x] >> (y - 1)) & 1) : 1;
                    UInt64 nextBit = (y < totalBits - 1) ? ((floor_layout[x] >> (y + 1)) & 1) : 1;
                    UInt32 combinedBits = (UInt32)((nextBit << 2) | (currentBit << 1) | previousBit);

                    // Extract bits of u64 one above X
                    UInt64 upper_buffer = ((x - 1) < 0)? UInt64.MaxValue: floor_layout[x - 1];
                    UInt64 upper_currentBit = (upper_buffer >> y) & 1;
                    UInt64 upper_previousBit = (y > 0) ? ((upper_buffer >> (y - 1)) & 1) : 1;
                    UInt64 upper_nextBit = (y < totalBits - 1) ? ((upper_buffer >> (y + 1)) & 1) : 1;
                    UInt32 upper_combinedBits = (UInt32)((upper_nextBit << 2) | (upper_currentBit << 1) | upper_previousBit);

                    // Extract bits of u64 one below X
                    UInt64 lower_buffer = ((x + 1) > totalBits-1)? UInt64.MaxValue: floor_layout[x + 1];
                    UInt64 lower_currentBit = (lower_buffer >> y) & 1;
                    UInt64 lower_previousBit = (y > 0) ? ((lower_buffer >> (y - 1)) & 1) : 1;
                    UInt64 lower_nextBit = (y < totalBits - 1) ? ((lower_buffer >> (y + 1)) & 1) : 1;
                    UInt32 lower_combinedBits = (UInt32)((lower_nextBit << 2) | (lower_currentBit << 1) | lower_previousBit);

                    int count = count_ones_exclude_middle(combinedBits) + count_ones(upper_combinedBits) + count_ones(lower_combinedBits);

                    if(count >= threshhold) {

                        UInt64 mask = (UInt64)1 << y; // Calculate the mask based on MSB index (63 - bitIndex)
                        bit_map_buffer[x] |= mask;
                    }

                    //Console.Write($"{count} ");

                }
                //Console.WriteLine();
            }


            //for(int x = 0; x < 64; x++)
            //    log_u64(bit_map_buffer[x]);

            //Console.WriteLine();
            floor_layout = bit_map_buffer;
        }

        // imgui Window
        private int tile_display_size = 7;

        private float inital_density = 0.37f;
        private int[] iterations = new int[] {4,4,4,4,4};
        private static Random random = new Random();
        private UInt64[] floor_layout = new UInt64[64];
        private readonly UInt64 map_bit_mask = 0xEFFFFFFFFFFFFFFE; // Binary: 01111111 11111111 11111111 11111111 11111111 11111111 11111111 11111110

        private void log_u64(UInt64 number) {

            string binaryRepresentation = Convert.ToString((long)number, 2).PadLeft(64, '0');

            // Replace '0' with ' ' (space) and '1' with 'X'
            char[] binaryChars = binaryRepresentation.Select(c => c == '0' ? ' ' : 'X').ToArray();
            string formattedBinary = new string(binaryChars);

            Console.WriteLine($"Map: |{formattedBinary}|");
        }


        // Function to count the number of '1's in a 3-bit number
        private static int count_ones(uint num) {

            int count = 0;
            for(int i = 0; i < 3; i++) {
                if((num & (1 << i)) != 0)
                    count++;
            }
            return count;
        }

        // Function to count the number of '1's in the leftmost and rightmost bits of a 3-bit number
        private static int count_ones_exclude_middle(uint num) {

            int count = 0;
            for(int i = 0; i <= 2; i += 2) {
                if((num & (1 << i)) != 0) 
                    count++;
            }
            return count;
        }

        // Function to generate a UInt64 value with specified density of bits flipped
        static UInt64 generate_random_UInt64_with_density(double density) {

            Random random = new Random();
            UInt64 result = 0;
            for(int i = 0; i < 64; i++) {
            
                double randomValue = random.NextDouble();
                if(randomValue < density)
                    result |= (UInt64)1 << i;
            }
            return result;
        }

    }
}


/*



*/